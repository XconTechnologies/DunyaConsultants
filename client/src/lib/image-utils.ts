/**
 * Frontend utility to extract alt text from image filenames
 * Keeps frontend and backend in sync for image handling
 */

/**
 * Extract human-readable alt text from an image filename
 * @param filename - The image filename or URL
 * @returns Clean alt text
 */
export function extractAltText(filename: string | null | undefined): string {
  if (!filename) return '';
  
  // Extract filename from URL if needed
  const name = filename.split('/').pop() || filename;
  
  // Remove file extension
  let altText = name.replace(/\.(webp|png|jpg|jpeg|gif|svg)$/i, '');
  
  // Remove timestamp patterns (numbers with 13+ digits)
  altText = altText.replace(/_\d{13,}/g, '');
  
  // Remove hash patterns (8+ character alphanumeric strings)
  altText = altText.replace(/_[a-f0-9]{8,}/gi, '');
  
  // Remove remaining underscores and replace with spaces
  altText = altText.replace(/_/g, ' ');
  
  // Replace hyphens with spaces
  altText = altText.replace(/-/g, ' ');
  
  // Remove multiple spaces
  altText = altText.replace(/\s+/g, ' ');
  
  // Trim whitespace
  altText = altText.trim();
  
  // Capitalize first letter of each word
  altText = altText.split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
  
  return altText;
}

/**
 * Get image props with automatic alt text and title
 * If alt text is not assigned, auto-detects the title from filename
 * @param src - Image source URL
 * @param customAlt - Optional custom alt text (overrides auto-generated)
 * @param customTitle - Optional custom title (overrides auto-generated)
 * @returns Object with src, alt, and title
 */
export function getImageProps(
  src: string | null | undefined, 
  customAlt?: string,
  customTitle?: string
) {
  const autoGenerated = extractAltText(src);
  
  return {
    src: src || '',
    alt: customAlt || autoGenerated, // Auto-detect if not assigned
    title: customTitle || autoGenerated, // Auto-detect title from filename
  };
}

/**
 * Convert image URL to WebP format if not already
 * @param url - Original image URL
 * @returns WebP URL
 */
export function toWebP(url: string | null | undefined): string {
  if (!url) return '';
  
  // If already WebP, return as-is
  if (url.endsWith('.webp')) return url;
  
  // Replace extension with .webp
  return url.replace(/\.(png|jpg|jpeg|gif)$/i, '.webp');
}

/**
 * Check if an image URL is from the uploads API or object storage (not attached_assets)
 * NOTE: This checks if it's an uploaded image, but doesn't mean it has responsive variants!
 * Use hasResponsiveVariants() to check if srcset should be generated
 * @param src - Image source URL
 * @returns true if uploaded image
 */
export function isUploadedImage(src: string): boolean {
  return src.includes('/api/uploads/') || src.includes('/api/admin/media/') || src.includes('/objects/uploads/');
}

/**
 * Check if an image has pre-generated responsive variants
 * Only object storage images have responsive variants (640w, 960w, 1280w)
 * Regular /api/uploads/ images do NOT have variants and should not use srcset
 * @param src - Image source URL
 * @returns true if image has responsive variants
 */
export function hasResponsiveVariants(src: string): boolean {
  // Only object storage images have pre-generated responsive variants
  return src.includes('/objects/uploads/');
}

/**
 * Extract base filename from image URL (without width suffix and extension)
 * Example: "/api/uploads/image_123456-640w.webp" -> "image_123456"
 * Example: "/api/uploads/image_123456.png" -> "image_123456"
 * @param src - Image source URL
 * @returns Base filename
 */
export function getBaseFilename(src: string): string {
  const filename = src.split('/').pop() || '';
  
  // First remove any extension (.webp, .png, .jpg, .jpeg, .gif)
  let baseName = filename.replace(/\.(webp|png|jpg|jpeg|gif)$/i, '');
  
  // Then remove width suffix if present (e.g., -640w, -960w, -1280w)
  baseName = baseName.replace(/-\d+w$/i, '');
  
  return baseName;
}

/**
 * Generate responsive srcset for uploaded images
 * Creates srcset with multiple sizes for optimal loading
 * IMPORTANT: Only generates srcset for /objects/uploads/ images that have pre-generated variants
 * Regular /api/uploads/ images do NOT have variants and will cause 404s if srcset is generated
 * @param src - Original image source URL
 * @returns srcset string or undefined if not applicable
 */
export function generateResponsiveSrcSet(src: string): string | undefined {
  // Only generate srcset for images that actually have responsive variants
  if (!hasResponsiveVariants(src)) {
    return undefined;
  }
  
  // Extract the directory path and base filename
  const lastSlashIndex = src.lastIndexOf('/');
  const basePath = src.substring(0, lastSlashIndex + 1);
  const baseFilename = getBaseFilename(src);
  
  // Get the original file extension from src
  const filename = src.split('/').pop() || '';
  const extension = filename.match(/\.(webp|png|jpg|jpeg|gif)$/i)?.[0] || '.webp';
  
  // Conservative approach: Only use sizes that most legacy images have
  // Legacy images typically have 960w and 1280w
  // New uploads (after Nov 2025) have all sizes (320, 640, 960, 1280)
  const srcSetParts: string[] = [];
  
  // Mobile and tablet sizes (commonly available)
  const sizes = [640, 960, 1280];
  sizes.forEach(width => {
    const url = `${basePath}${baseFilename}-${width}w${extension}`;
    srcSetParts.push(`${url} ${width}w`);
  });
  
  // Add original as largest size
  srcSetParts.push(`${src} 2000w`);
  
  return srcSetParts.join(', ');
}

/**
 * Generate sizes attribute for responsive images
 * Defines when to use which image size based on viewport
 * @param customSizes - Optional custom sizes string
 * @returns sizes attribute value
 */
export function generateSizesAttribute(customSizes?: string): string {
  if (customSizes) return customSizes;
  
  // Default responsive sizes strategy:
  // - Mobile portrait (< 480px): use 640w image (100vw)
  // - Mobile landscape/Tablet (480px - 1024px): use 960w image (100vw)
  // - Desktop (> 1024px): use 1280w or original image (1280px max)
  return '(max-width: 480px) 100vw, (max-width: 1024px) 100vw, 1280px';
}

/**
 * Normalize featured image URL - handles full URLs, relative paths, and legacy formats
 * @param imageUrl - Image URL from blog post (can be full URL or relative path)
 * @returns Normalized image URL ready for rendering
 */
export function normalizeFeaturedImageUrl(imageUrl: string | null | undefined): string {
  const fallbackImage = '/attached_assets/generated_images/Blog_placeholder_image_201b6785.png';
  
  if (!imageUrl || imageUrl.trim() === '') {
    return fallbackImage;
  }
  
  const trimmed = imageUrl.trim();
  
  // Already a full URL (new format from Featured Image Management System)
  if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
    return trimmed;
  }
  
  // Relative paths - add leading slash if needed
  if (trimmed.startsWith('/')) {
    return trimmed;
  }
  
  // Legacy formats without leading slash
  return `/${trimmed}`;
}

/**
 * Get blog post featured image properties
 * @param post - Blog post object with featured image data
 * @returns Object with src, alt, and title for the image
 */
export function getBlogFeaturedImageProps(post: {
  featuredImage?: string | null;
  featured_image?: string | null;
  featuredImageAlt?: string | null;
  featured_image_alt?: string | null;
  featuredImageTitle?: string | null;
  featured_image_title?: string | null;
  title?: string;
}) {
  const imageUrl = post.featuredImage || post.featured_image;
  const src = normalizeFeaturedImageUrl(imageUrl);
  
  // Use provided alt/title, or extract from filename, or fallback to post title
  const alt = post.featuredImageAlt || post.featured_image_alt || extractAltText(imageUrl) || post.title || '';
  const title = post.featuredImageTitle || post.featured_image_title || extractAltText(imageUrl) || post.title || '';
  
  return {
    src,
    alt,
    title,
  };
}
